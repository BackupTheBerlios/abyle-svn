#!/usr/bin/env python

# Copyright (C) 2005  	Stefan Nistelberger (scuq@gmx.net)
# 			Daniel Schrammel (nowx@gmx.at)
# abyle firewall
# abyle - python iptables config script
# 
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
# 
# http://www.gnu.org/licenses/gpl.txt

import os
import sys
import re
import string
import types
import datetime
from optparse import OptionParser
from abyle_output import abyle_output
from abyle_firewall import abyle_firewall
from abyle_config_xmlparser import abyle_config_parse
from abyle_changelog_xmlparser import abyle_changelog_parse
from xml.sax.handler import ContentHandler
from xml.sax import make_parser

def check_well_formedness(file):
        try:
                saxparser = make_parser()
                saxparser.setContentHandler(ContentHandler())
                saxparser.parse(file)
                return "ok"
        except Exception, e:
                return str(file) + " is NOT well-formed! " + str(e)

def flush_chains(dryrun, table, LOGFILE, verbose, output):
	cmdIn = ""
	cmdOut = ""
	cmdErr = ""
	
	if table == "all":

		if not dryrun:
			cmdIn, cmdOut, cmdErr = os.popen3(IPTABLES+' -F')
			cmdErr = cmdErr.readlines()
			cmdOut = cmdOut.readlines()
		if verbose:
			abyle_output("flush_chains", cmdErr, cmdOut, "flushed chains.", "default", LOGFILE)
		else:
			output.startup(".")
		
		if not dryrun:
			cmdIn, cmdOut, cmdErr = os.popen3(IPTABLES+' -X')
			cmdErr = cmdErr.readlines()
			cmdOut = cmdOut.readlines()
		if verbose:
			abyle_output("flush_chains", cmdErr, cmdOut, "deleted chains.", "default", LOGFILE)
		else:
			output.startup(".")

	else:
		if not dryrun:
			cmdIn, cmdOut, cmdErr = os.popen3(IPTABLES+' -t '+table+' -F')
			cmdErr = cmdErr.readlines()
			cmdOut = cmdOut.readlines()
		if verbose:
			abyle_output("flush_chains", cmdErr, cmdOut, "flushed chains for table "+table+".", "default", LOGFILE)
		else:
			output.startup(".")
		
		if not dryrun:
			cmdIn, cmdOut, cmdErr = os.popen3(IPTABLES+' -t '+table+' -X')
			cmdErr = cmdErr.readlines()
			cmdOut = cmdOut.readlines()
		if verbose:
			abyle_output("flush_chains", cmdErr, cmdOut, "deleted chains for table "+table+".", "default", LOGFILE)
		else:
			output.startup(".")



def prepare_firewall(KERNELMODULES):
	for module in KERNELMODULES:
		cmdIn, cmdOut, cmdErr = os.popen3(MODPROBE+' -r '+module)
	abyle_output("prepare_firewall", cmdErr.readlines(), cmdOut.readlines(), "unloaded iptables kernel-modules.")

	for module in KERNELMODULES:
        	cmdIn, cmdOut, cmdErr = os.popen3(MODPROBE+' '+module)
	abyle_output("prepare_firewall", cmdErr.readlines(), cmdOut.readlines(), "loaded iptables kernel-modules.")

def getAllInterfaces():
	cmdIn, cmdOut, cmdErr = os.popen3('cat /proc/net/dev | grep ":" | cut -f1 -d ":"')
	EXISTING_INTERFACES=[]
	for int in cmdOut.readlines():
		int = re.sub("^[^\w]+","",int)
		int = re.sub("[^\w]+$","",int)
		int = re.sub("\n$","",int)
		EXISTING_INTERFACES.append(int)
	return EXISTING_INTERFACES

def stopfw(dryrun, verbose, LOGFILE):
	output = abyle_output("","","","","default", LOGFILE)
	if verbose:
               	now = datetime.datetime.now()
              	now =  now.strftime("%Y/%m/%d %H:%M:%S")

		abyle_output("", "", "", "","blue", LOGFILE)
		abyle_output("", "", "", "Stopping Firewall","blue", LOGFILE)
		abyle_output("", "", "", "","blue", LOGFILE)
		abyle_output("", "", "", "time: "+now,"default", LOGFILE)
		abyle_output("", "", "", "","blue", LOGFILE)
	else:
		output.startup("Stopping Firewall")

	flush_chains(dryrun, "all", LOGFILE, verbose, output)
	flush_chains(dryrun, "nat", LOGFILE, verbose, output)

	if not verbose:
		con_size = string.join(os.popen("stty size").readlines())
		arr_con_size = string.split(con_size," ")
		size = string.atoi(arr_con_size[1])-13
		size = size+4
		a = string.join(os.popen("echo -n \033[$(("+str(size)+"))G && echo -n   [DONE] "))
		output.startup(a, "blue", "yes")

def main():

	global IPTABLES
	global MODPROBE

	parser = OptionParser()
	parser.add_option("-s", "--start", action="store_true", dest="startfw", default=False, help="start the firewall")
	parser.add_option("-b", "--stop", action="store_true", dest="stopfw", default=False, help="stop (blow out) the firewall")
	parser.add_option("-d", "--dry-run", action="store_true", dest="dryrunfw", default=False, help="dryrun, dont excecute iptables, use with -s or -b flag")
	parser.add_option("-i", "--status", action="store_true", dest="statusfw", default=False, help="status of your wall of fire")
	parser.add_option("-r", "--reload-modules", action="store_true", dest="reloadmod", default=False, help="reload iptables kernel modules")
	parser.add_option("-v", "--verbose", action="store_true", dest="verbose", default=False, help="show verbose output of fw start/stop")
	parser.add_option("-V", "--version", action="store_true", dest="version", default=False, help="show version of pyfw modules")
	parser.add_option("-t", "--install-ifs", action="store_true", dest="install_ifs", default=False, help="install template config for any existing interface")
	parser.add_option("-p", "--config-path", dest="fwconfigpath", help="path to firewall configuration directory")
	parser.add_option("-c", "--config-file-name", dest="xmlconfig", help="name of the configuration file")

	(options, args) = parser.parse_args()

	try:


	 if options.fwconfigpath:
	  	FWCONFIGPATH = options.fwconfigpath
	 else:
		FWCONFIGPATH="/etc/abyle/"

	 if options.xmlconfig:
		XMLCONFIG = options.xmlconfig
	 else:
		XMLCONFIG="config.xml"

	 if not os.path.exists(FWCONFIGPATH):
		abyle_output("cli_option_parser", "", "", "given config path: "+FWCONFIGPATH+" does not exist. exiting with status 2.")
		sys.exit(2)

	 if options.install_ifs:
		abyle_output("cli_option_parser", "", "", "copy template config for all existing interfaces! existing configs will be moved to "+FWCONFIGPATH+".old" )
		EXISTING_INTERFACES = getAllInterfaces()
		for int in EXISTING_INTERFACES:
			abyle_output("cli_option_parser", "", "", "copy template/interface to "+int)
			cmdIn, cmdOut, cmdErr = os.popen3('rm -rf '+FWCONFIGPATH+'.old')
			cmdIn, cmdOut, cmdErr = os.popen3('mkdir '+FWCONFIGPATH+'.old')
			cmdIn, cmdOut, cmdErr = os.popen3('mv '+FWCONFIGPATH+int+' '+FWCONFIGPATH+'.old/'+int)
			cmdIn, cmdOut, cmdErr = os.popen3('cp -r '+FWCONFIGPATH+'template/interface '+FWCONFIGPATH+int)
		
         checkWellformed = check_well_formedness(FWCONFIGPATH+XMLCONFIG)
         if checkWellformed != "ok":
                abyle_output("","","",checkWellformed, "red")
                sys.exit(1)

	# parse the config file
	 global_config = abyle_config_parse(FWCONFIGPATH, "default", XMLCONFIG)
	 try: 
		LOGFILE =  global_config.getConfig("logfile")
	 except IndexError:
		LOGFILE = '/dev/null'
	 RULESFILE =  global_config.getConfig("rulesfile")
	 KERNELMODULES  =  global_config.getConfig("modules")
	 PROTECTED_INTERFACES = global_config.getConfig("interface")
	 MODPROBE = global_config.getConfig("modprobe")
	 IPTABLES = global_config.getConfig("iptables")
	 IPT_XMLCONFIG = global_config.getConfig("iptflagfile")
         ECHOCMD = global_config.getConfig("echocmd")
	 # end parse the config file


	 if not options.statusfw and not options.stopfw and not options.reloadmod and not options.startfw and not options.version and not options.dryrunfw and not options.install_ifs:
		abyle_output("cli_option_parser", "", "", "no options given use --help to get more info")
	 else:
	
		if options.statusfw:
			cmdIn, cmdOut, cmdErr = os.popen3(IPTABLES+' -v -L  && '+IPTABLES+' -v -L PREROUTING -t nat && '+IPTABLES+' -v -L POSTROUTING -t nat' )
			abyle_output("cli_option_parser", cmdErr.readlines(), cmdOut.readlines(), "iptables -L -v -- failed??")

		if options.stopfw:
			stopfw(options.dryrunfw, options.verbose, LOGFILE)	

		if options.reloadmod:
			prepare_firewall(KERNELMODULES)

		if options.version:
			changelog = abyle_changelog_parse(FWCONFIGPATH, "changelog.xml")
			changelog.getChangelog()

		if options.startfw:
			EXISTING_INTERFACES = getAllInterfaces()
			for int in EXISTING_INTERFACES:
				intcnt = PROTECTED_INTERFACES.count(int)
				if intcnt == 0:
					abyle_output("pyfwscript_startfw_config_check", "", "", "WARNING!!! interface "+int+" not configured everything will be blocked!")
			stopfw(options.dryrunfw, options.verbose, LOGFILE)
			fw = abyle_firewall(options.dryrunfw, IPTABLES, FWCONFIGPATH, RULESFILE, IPT_XMLCONFIG, XMLCONFIG, ECHOCMD, LOGFILE, options.verbose)
			PIcnt_max = 0
			for iface in PROTECTED_INTERFACES:
				PIcnt_max = PIcnt_max + 1	

			PIcnt = 0
			for iface in PROTECTED_INTERFACES:
				PIcnt = PIcnt + 1
				fw.buildUp(iface, FWCONFIGPATH, options.verbose)
			
				if PIcnt == PIcnt_max:
					fw.buildUpFinish(options.verbose)

	except KeyboardInterrupt:
		print "Ctrl+C recognized."
		print "it is not a good idea to disturb a starting wall of fire!"

if __name__=='__main__': main()

